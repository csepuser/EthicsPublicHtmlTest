<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN">
<html><!-- InstanceBegin template="/Templates/new_sea.dwt" codeOutsideHTMLIsLocked="false" -->
<head>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
<link rel="stylesheet" type="text/css" href="http://ethics.iit.edu/sea/styles/jScrollPane.css" media="all" />
<link rel="stylesheet" type="text/css" href="http://ethics.iit.edu/sea/styles/style_sea.css" media="all" />
<link rel="stylesheet" type="text/css" href="http://ethics.iit.edu/sea/styles/superfish.css" media="screen" />
<title>Center for the Study of Ethics in the Professions at IIT</title>
<link rel="shortcut icon" href="http://ethics.iit.edu/newlayout/favicon.ico" />
<meta name="keywords" title="keywords" content="" />
<meta name="description" content="" />




<script type="text/javascript">

  var _gaq = _gaq || [];
  _gaq.push(['_setAccount', 'UA-8938192-11']);
  _gaq.push(['_trackPageview']);

  (function() {
    var ga = document.createElement('script'); ga.type = 'text/javascript'; ga.async = true;
    ga.src = ('https:' == document.location.protocol ? 'https://ssl' : 'http://www') + '.google-analytics.com/ga.js';
    var s = document.getElementsByTagName('script')[0]; s.parentNode.insertBefore(ga, s);
  })();

</script>

<script src="http://code.jquery.com/jquery-1.7.1.js"></script>
<script src="http://ethics.iit.edu/sea/js/jScrollPane.js"></script>
<script src="http://ethics.iit.edu/sea/js/hoverIntent.js"></script> 
<script src="http://ethics.iit.edu/sea/js/superfish.js"></script>
<script type="text/javascript"> 
var pageTracker = _gat._getTracker("UA-3621988-3");
pageTracker._trackPageview();
</script>

<script type="text/javascript">
	$(function(){ $('#inner').jScrollPane(); });	
	 
    $(document).ready(function(){ $("ul.sf-menu").superfish(); }); 
</script>

</head>

<body>
<div id="wrapper">
<div id="banner"></div>
<a name="home"></a>


<div style="width: 80em; height: 2.5em;">
<ul class="sf-menu sf-js-enabled sf-shadow">
<li ><a href="http://ethics.iit.edu/sea/sea.php/100" style="color:white;" >Home</a></li>
<li ><a href="http://ethics.iit.edu/sea/sea.php/1" style="color:white;" >About</a></li>
<li ><a href="http://ethics.iit.edu/sea/sea.php/31" style="color:white;"  class="sf-with-ul" >Guides</a>
<ul style="display: none; visibility: hidden; ">
		<li ><a href="http://ethics.iit.edu/sea/sea.php/2" style="color:white;" class="sf-with-ul" >Index by Date</a>
        <ul style="display: none; visibility: hidden; left:20em; top: -1px; ">
			<li ><a href="http://ethics.iit.edu/sea/sea.php/11" style="color:white;" >1991</a></li>
			<li ><a href="http://ethics.iit.edu/sea/sea.php/12" style="color:white;" >1992</a></li>
			<li ><a href="http://ethics.iit.edu/sea/sea.php/13" style="color:white;" >1993</a></li>		
 			<li ><a href="http://ethics.iit.edu/sea/sea.php/14" style="color:white;" >1994</a></li>
			<li ><a href="http://ethics.iit.edu/sea/sea.php/15" style="color:white;" >1995</a></li>
			<li ><a href="http://ethics.iit.edu/sea/sea.php/16" style="color:white;" >1996</a></li>    
 			<li ><a href="http://ethics.iit.edu/sea/sea.php/17" style="color:white;" >1997</a></li>
			<li ><a href="http://ethics.iit.edu/sea/sea.php/18" style="color:white;" >1998</a></li>
			<li ><a href="http://ethics.iit.edu/sea/sea.php/19" style="color:white;" >1999</a></li>	           
 			<li ><a href="http://ethics.iit.edu/sea/sea.php/20" style="color:white;" >2000</a></li>
			<li ><a href="http://ethics.iit.edu/sea/sea.php/21" style="color:white;" >2001</a></li>
			<li ><a href="http://ethics.iit.edu/sea/sea.php/22" style="color:white;" >2002</a></li>	                
            <li ><a href="http://ethics.iit.edu/sea/sea.php/25" style="color:white;" >2005</a></li>	 
            
		</ul>
        </li>
		<li ><a href="http://ethics.iit.edu/sea/sea.php/3" style="color:white;" >Requesting Access</a></li>
		<li ><a href="http://ethics.iit.edu/sea/sea.php/4" style="color:white;" >Versions of SE Code of Ethics</a></li>		
 		<li ><a href="http://ethics.iit.edu/sea/sea.php/5" style="color:white;" >Bibliography</a></li>
		<li ><a href="http://ethics.iit.edu/sea/sea.php/6" style="color:white;" >Interviews of Participants</a></li>
		<li ><a href="http://ethics.iit.edu/sea/sea.php/7" style="color:white;" >Acronyms</a></li>    
</ul>
</li>
<li ><a href="http://ethics.iit.edu/sea/sea.php/9" style="color:white;" >CodeMaking</a></li>
<li ><a href="http://ethics.iit.edu/sea/sea.php/8" style="color:white;" >Search</a></li>
<li ><a href="http://ethics.iit.edu/sea/sea.php/32" style="color:white;" >Contact</a></li>
<li ><a href="http://ethics.iit.edu/" style="color:white; border-right:1px solid white;" >CSEP</a></li>
</ul>
</div>

<div style=" width: 76em; height:auto; padding:2em; min-height:64.6em;">
<div id="viewer">
	
<div id="content"> 
		
	
      <div id="organization"> <strong>Author: </strong><!-- InstanceBeginEditable name="author" --> 
       Gary 
 
       Ford<!-- InstanceEndEditable --></div>
		
		
      <div id="approved"> <strong>Date:</strong> <!-- InstanceBeginEditable name="date" -->October
           28, 1992<!-- InstanceEndEditable --> 
      </div>
		
      <div id="approved"> <strong>Subject: </strong><!-- InstanceBeginEditable name="subject" -->Email
           from Gary Ford: &quot;Licensing Engineering Faculty in West Virginia&quot;<!-- InstanceEndEditable --></div>
		
      <div id="source"> <strong> Recepient: </strong><!-- InstanceBeginEditable name="recepient" -->Unknown<!-- InstanceEndEditable --></div>
      <div id="source"> <strong> Format: </strong><!-- InstanceBeginEditable name="format" -->E-mail<!-- InstanceEndEditable --></div>
      <div id="previous"> <strong> Source: </strong><!-- InstanceBeginEditable name="source" --> 
         Don 
 
         Gotterbarn <!-- InstanceEndEditable --></div>
		
		<div id="title"> <h3> <!-- InstanceBeginEditable name="title" -->Licensing
 		      Engineering Faculty in West Virginia 
<title>Center for the Study of Ethics in the Professions</title>
<!-- InstanceEndEditable --> </h3></div>		
		
      <!-- InstanceBeginEditable name="content" --> 
                       <p align="justify">Frances Van Scoy of West Virginia University 
 
                     reports that some engineering faculty are objecting to CS 
 
                     faculty teaching software engineering, because of state law 
 
                     requiring engineering professors to be licensed engineers. 
 
                     West Virginia, like most states, forbids persons other than 
 
                     licensed engineers from engaging in the &quot;practice of 
 
                     engineering.&quot; Below is the definition of that term from 
 
                     the WVa law. What do you think? Does it apply to faculty in 
 
                     typical undergraduate engineering courses? Does it apply to 
 
                     faculty teaching &quot;software engineering&quot; or &quot;advanced 
 
                     software engineering&quot;?</p>
 
                   <p align="justify"> ======== </p>
 
                   <p align="justify">&quot;Practice of engineering&quot; means 
 
                     any service or creative work, the adequate performance of 
 
                     which requires engineering education, training and experience 
 
                     in the application of special knowledge of the mathematical, 
 
                     physical and engineering sciences to such services or creative 
 
                     work as consultation, investigation, evaluation, planning 
 
                     and design of engineering works and systems; planning the 
 
                     use of land and water; teaching of advanced engineering subjects, 
 
                     engineering surveys and studies; and the review of construction 
 
                     for the purpose of assuring compliance with drawings and specifications 
 
                     any of which embraces such services or work, either public 
 
                     or private, in connection with any utilities, structures, 
 
                     buildings, machines, equipment, processes, work systems, projects 
 
                     and industrial or consumer products or equipment of a mechanical, 
 
                     electrical, hydraulic, pneumatic or thermal nature, insofar 
 
                     as they involve safeguarding life, health or property, and 
 
                     including such other professional services as may be necessary 
 
                     to the planning, progress and completion of any engineering 
 
                     services.</p>
 
                   <p align="justify"> End of article 340 (of 349)??what next? 
 
                     [npq] </p>
 
                   <p align="justify">|&gt; |&gt; &quot;Practice of engineering&quot; 
 
                     means any service or creative work, the adequate repeat of 
 
                     above article<br>
 
                     |&gt; to the planning, progress and completion of any engineering 
 
                     services. <br>
 
                     |&gt; I would think that effect of laws is more a matter of 
 
                     the means of regulation than the specific language used in 
 
                     the law (except in matters of adjudication). Here the interest 
 
                     should be on the licensing procedures; i.e., what qualifies 
 
                     someone to be a &quot;licensed&quot; engineer. Thus, any degree 
 
                     of applicability of the law to &quot;teaching of advanced 
 
                     [software] engineering subjects, [software] engineering surveys 
 
                     and [software engineering?] studies&quot; would require a 
 
                     licensing procedure ?? which I assume does not exist. As for 
 
                     the applicability question, one would only need to look at 
 
                     the regulatory process as it exists today to find out what 
 
                     undergraduate and graduate engineering courses fall under 
 
                     its jurisdiction. It is the job of regulatory agencies to 
 
                     enforce laws through regulatory processes. What we may think 
 
                     about the applicability question is irrelevant. Even if we 
 
                     were asked to advise them, I shudder at the thought of what 
 
                     that advice might be. If the West Virginia agency responsible 
 
                     for enforcing this law decides to place software engineering 
 
                     under its jurisdiction, it's they who must propose licensing 
 
                     procedures and determine applicability. In any event, I suspect 
 
                     that NJ, WVa, and others are just the beginning of the questions 
 
                     concerning who gets to call themselves a software engineer. 
 
                     <br>
 
                     Larry Howard (lph@sei.cmu.edu)<br>
 
                     | Software Engineering Institute, Carnegie Mellon Univ. <br>
 
                     | Vera pro gratiis. </p>
 
                   <p align="justify"> </p>
 
                   <p align="justify">MSE CMU</p>
 
                   <p align="justify">Article 343 (6 more) in cmu.sei.edu: From: 
 
                     Mario Barbacci &lt;mrb@SEI.CMU.EDU&gt; Subject: New Carnegie 
 
                     Mellon Degree Organization: Software Engineering Institute 
 
                     Date: Mon, 16 Nov 1992 14:14:41 GMT Laurie, This item might 
 
                     be of interest to readers of your SE Education News column 
 
                     (Delaney is the editor of the CMU official newsletter) In 
 
                     article &lt;Mf1dt4C00iV1Q2_UYQ@andrew.cmu.edu&gt;, ed47+@andrew.cmu.edu 
 
                     (&quot;Edmund J. Delaney&quot;) writes: <br>
 
                     |&gt; |&gt; |&gt; In response to increasing industry demand 
 
                     for software engineers, the <br>
 
                     |&gt; School of Computer Science (SCS) and the Software Engineering 
 
                     Institute <br>
 
                     |&gt; (SEI) have combined their resources in a new five?year 
 
                     program leading <br>
 
                     |&gt; to a bachelor's degree in computer science and a master's 
 
                     degree in <br>
 
                     |&gt; software engineering. The program will place student 
 
                     interns in <br>
 
                     |&gt; real?world software development projects where they 
 
                     may spend two or <br>
 
                     |&gt; three summer sessions with such companies as Apple, 
 
                     Intel, General<br>
 
                     |&gt; Electric, Motorola and NCR.<br>
 
                     |&gt; &quot;This is a degree for people who are determined 
 
                     to practice the<br>
 
                     |&gt; discipline,&quot; says Mary Shaw, associate dean for 
 
                     professional education <br>
 
                     |&gt; programs at SCS. &quot;There are very few other opportunities 
 
                     for students to<br>
 
                     |&gt; include a substantial design experience in a high?quality 
 
                     degree <br>
 
                     |&gt; program.&quot; <br>
 
                     |&gt; ??The program eliminates electives required by the conventional 
 
                     <br>
 
                     |&gt; bachelor's degree track but specifies probability and 
 
                     statistics, <br>
 
                     |&gt; mathematical logic and technical writing courses. <br>
 
                     |&gt; ??Application deadline for the new program is Dec. 15. 
 
                     Information: <br>
 
                     |&gt; Undergraduate Office, SCS, Wean 4102.<br>
 
                     |&gt; |&gt; ?? Mario R. Barbacci, Director, Real-time Distributed 
 
                     Systems Program Software Engineering Institute, Carnegie Mellon 
 
                     U., Pittsburgh PA 15213 Tel: +1 (412) 268?7704; FAX: +1 (412) 
 
                     258?5758 End of article 343 (of 349)??what next? [npq] </p>
 
                   <p align="justify"> PROJECT PLANNING Article 11993 (172 more) 
 
                     in comp.software?eng: From: Thomas N Erickson Subject: Re: 
 
                     Project Planning Software Keywords: project planning Date: 
 
                     16 Dec 92 15:52:04 GMT Organization: The World Public Access 
 
                     UNIX, Brookline, MA Lines: 28 downey@tripos.com (Tom Downey) 
 
                     writes:<br>
 
                     &gt;Hi,<br>
 
                     &gt;We are in need of a good project planning package. We 
 
                     have evaluated several <br>
 
                     &gt;products but are not satisfied with any of them. <br>
 
                     &gt;Can anyone suggest any good products? It should run on 
 
                     Unix/X?Windows. <br>
 
                     &gt;Thanks, and sorry if this is a FAQ. Try contacting PSDI, 
 
                     who have recently introduced a system called Project/2 Series 
 
                     X. It is a full function system running on several platforms. 
 
                     <br>
 
                     PSDI 20 University Road Cambridge, MA 02138 (617)661?1444 
 
                     ?? Tom Erickson Alsys tne@world.std.com </p>
 
                   <p align="justify"> HOOD Article 11997 (168 more) in comp.software-eng: 
 
                     <br>
 
                     From: Paul Moore <br>
 
                     Subject: HOOD - Summary of responses <br>
 
                     Date: Wed, 16 Dec 92 15:41:16 +0100</p>
 
                   <p align="justify"> Some time ago, placed a note requesting 
 
                     information and comments about HOOD. Thi s note summarises 
 
                     the responses received. My thanks to the following people 
 
                     for offering their comments and advice:</p>
 
                   <p align="justify"> ewoods@uk3.bull.co.uk (Eoin Woods) <br>
 
                     cornwell@minster.york.ac.uk (Pete Cornwell ) <br>
 
                     aro@aberystwyth.ac.uk (Abdrew Ormsby) a<br>
 
                     guilla1@cs.ualberta.ca <br>
 
                     mangane@SOLEIL.matra-espace.fr (Laurent MANGANE) <br>
 
                     jcampos@gmv.es (Francisco Javier Campos) <br>
 
                     cit_toop@rcvie.co.at (Gerard Gobillard) </p>
 
                   <p align="justify">In summary, it appears that HOOD is a method 
 
                     that does not align itself very well with traditional structured 
 
                     analysis techniques (Yourdon, Ward/Mellor, Hatley, etc), due 
 
                     to its being an object?oriented design technique. It also 
 
                     doesn't appear to integrate very well with the currently in?vogue 
 
                     object?oriented analysis techniques. HOOD appears to have 
 
                     been forced on the European Space Agency by a French aerospace 
 
                     company (Matra, I believe, but open to correct ion). However, 
 
                     it appears to be well supported by a number of CASE tool supplier 
 
                     s, even though the documentation describing the methodology 
 
                     in detail is more or less non?existent. Anyway, my apologies 
 
                     for taking so long to reply. By the way, I didn't have any&quot;Please 
 
                     let me have what you have received&quot; type of requests, 
 
                     but I feel that the responses will be of sufficient interest 
 
                     anyway. If you have any comments/observations, please email 
 
                     me, as I don't have a News f eed. </p>
 
                   <p align="justify">Paul Moore </p>
 
                   <p align="justify">email: sp_pm@space.alcbel.be</p>
 
                   <p align="justify"> Here follows my original posting, followed 
 
                     by the responses I received back. =============================================================================== 
 
                   </p>
 
                   <p align="justify">Hello, </p>
 
                   <p align="justify">I have just started working for a company 
 
                     working in the aerospace field. I have some questions about 
 
                     the use of HOOD, and I would be grateful for some advice.</p>
 
                   <p align="justify"> 1. I have had some experience with the Ward/Mellor 
 
                     and Hatley/Pirbhai structured analysis methodologies. There 
 
                     are two excellent books available that explain how to use 
 
                     these methodologies [1] and [2], each with lots of examples 
 
                     showing how the method is used. It seems that the only documents 
 
                     available explaining how to use HOOD are the HOOD User Manual, 
 
                     and the HOOD Reference Manual. These two manuals do not explain 
 
                     how to use the methodology, and certainly do not explain the 
 
                     methodology to new users. Are there any better books available 
 
                     that teach the use of HOOD? It should *NOT* be necessary to 
 
                     attend a training course to learn how to use HOOD. </p>
 
                   <p align="justify">2. It seems that HOOD is used at the structured 
 
                     design level of the analysis/design/implementation software 
 
                     project cycle, as defined by Constantine/Page?Jones and Yourdon/Ward/Mellor. 
 
                     This means that its use should be preceeded by a structured 
 
                     analysis phase. Is this correct? How does it relate to modern 
 
                     structured analysis techniques, such as the two mentioned 
 
                     in point 1 above, and which structured analysis methodology 
 
                     is recommended for use with the HOOD methodology? </p>
 
                   <p align="justify">3. It seems that HOOD is oriented towards 
 
                     Ada as the implementation language. Does this mean that HOOD 
 
                     is still mandated by ESA when the language used is not Ada, 
 
                     for example C and C++. If so, can HOOD still be used if the 
 
                     implementation language is not Ada. For example, HOOD appears 
 
                     to take advantage of Ada's built-in inter-process-communication 
 
                     facilities. What if these facilities are not present in the 
 
                     implementation language used? I will summarise responses I 
 
                     get to the net, if sufficient interest warrants.</p>
 
                   <p align="justify"> Please respond by email, as I don't have 
 
                     a connection to the News.</p>
 
                   <p align="justify"> Regards,</p>
 
                   <p align="justify"> Paul [1] Structured Development for Real-Time 
 
                     Systems, Vols 1-3, Paul T. Ward and Stephen J. Mellor, 1985. 
 
                     [2] Strategies for Real-Time System Specification, Derek J. 
 
                     Hatley and Imtiaz A. Pirbhai, 1987. </p>
 
                   <p align="justify">Paul Moore, email: sp_pm@space.alcbel.be 
 
                     Alcatel Bell Telephone, Space Dept. TS 664, phone: (+32) 3/829.5024 
 
                     Berkenrodelei 33, 2660 Hoboken, Belgium </p>
 
                   <p align="justify"></p>
 
                   <p align="justify">From ewoods@uk03.bull.co.uk <br>
 
                     Tue Oct 13 19:08:57 1992<br>
 
                     From: ewoods@uk03.bull.co.uk (Eoin Woods) <br>
 
                     Message-Id: &lt;9210131140.AA12478@brno.uk03.bull.co.uk&gt; 
 
                     <br>
 
                     To: sp_pm@space.alcbel.be </p>
 
                   <p align="justify">There is a collection of papers published 
 
                     by UNICOM in the UK which gives interesting background information. 
 
                     I think the training course is the best option (I learned 
 
                     HOOD as part of my MSc course). Yes, HOOD is primarily a design 
 
                     method, not an analysis one. I have used W&amp;M with it and 
 
                     it seems to work OK! I don't think there is an &quot;official&quot; 
 
                     analysis method for it. It is *very* Ada biased. It has been 
 
                     used with other languages, but presumably they built a library 
 
                     to simulate the Ada facilities they needed. I did hear recently 
 
                     that ESA are using OOD (based on Booch) as well as HOOD (particularly 
 
                     for C++ project). However this is just hearsay, not fact. 
 
                     Eoin.</p>
 
                   <p align="justify"> | Eoin Woods <br>
 
                     | Tel : +44 442 88?4467 (Fax 4570) <br>
 
                     | Application Services Product Unit <br>
 
                     | BVN : (UK) 773?4467 <br>
 
                     | Bull Information Systems <br>
 
                     | Maxted Road <br>
 
                     | E.Woods@uk03.bull.co.uk <br>
 
                     | Hemel Hempstead, Herts HP2 7DZ, UK <br>
 
                     |...!relay1.uu.net!uknet!brno!ewoods | </p>
 
                   <p align="justify">---------------------------</p>
 
                   <p align="justify"> From cornwell@minster.york.ac.uk <br>
 
                     Wed Oct 14 17:08:41 1992</p>
 
                   <p align="justify"> I work at York University on Hard real-time 
 
                     HOOD which is essentially a superset of the original notation, 
 
                     so I've had a bit of experience in some of the areas you mentioned 
 
                     in your news posting... to summarise.... </p>
 
                   <p align="justify">1) I've only come across one other book that 
 
                     deals with HOOD in any depth and thats coolings book on real?time 
 
                     system design which gives a very general introduction to the 
 
                     method. When I originally started looking at HOOD all that 
 
                     was avaliable however was the reference and user manuals, 
 
                     and yes I agree these are generally pretty lousy. </p>
 
                   <p align="justify">2) I believe HOOD takes the view of &quot;here 
 
                     is the requirement document, lets start the design&quot;. 
 
                     Using the methods you cite would be difficult as HOOD is such 
 
                     a weird compromise between top?down and OO design methodologies. 
 
                   </p>
 
                   <p align="justify">3) Although the method is strongly related 
 
                     to Ada, there is movement within the HUG (HOOD USer Group) 
 
                     to gradually move away from Ada and attempt to make HOOD more 
 
                     generic, and hence more appealing to non-Ada using designers. 
 
                     At the moment however the various mapping rules only cover 
 
                     HOOD to Ada'83 , sorry I should say &quot;guidelines&quot; 
 
                     version 3.1 has guidelines rather than rules! Basically all 
 
                     the guidelines state for other languages is that as long as 
 
                     it has similar modularity / encapsulation features to Ada 
 
                     you should be OK (!).</p>
 
                   <p align="justify"> NB: I believe that version 4.0 of HOOD will 
 
                     have inheritance, but when this is due out is anyones guess. 
 
                     Also I dont know if this is an attempt to keep in step with 
 
                     the proposed changes to Ada 9X or to appeal to the OOP using 
 
                     community at large.</p>
 
                   <p align="justify"> From: aro@aberystwyth.ac.uk <br>
 
                     To: &quot; (Paul Moore)&quot; &lt;sp_pm@space.alcbel.be&gt; 
 
                     <br>
 
                     Subject: Repost: Please reread:</p>
 
                   <p align="justify"> Has anyone successfully used HOOD? I know 
 
                     of only one book which purports to explain how to use HOOD. 
 
                     This is &quot;Object?Oriented Design&quot; edited by Peter 
 
                     Robinson. I'm not terribly impressed by it; it is just a collection 
 
                     of papers given at a UNICOM seminar in London, is not well 
 
                     produced and is very, very expensive. If you are still interested, 
 
                     the book is published by Chapman &amp; Hall, a UK publisher. 
 
                     I'm not sure what the official position is on what you should 
 
                     use as the precusor to HOOD. The best people to ask might 
 
                     be those currently involved in its use on ESA and related 
 
                     projects. My view would be that some sort of object modelling 
 
                     analysis method would be far more appropriate start. You might 
 
                     find some useful hints in the book by Coad and Yourdon, &quot;Object-Oriented 
 
                     Analysis&quot;, (Yourdon Press/Prentice?Hall), though their 
 
                     notation is (of course) different to the HOOD notation. A 
 
                     better analysis method is described in &quot;Object?oriented 
 
                     modellin and design&quot; by Rumbaugh and others. Also published 
 
                     by Prentice-Hall. You might also talk to the various companies 
 
                     that are selling CASE tools for supporting use of HOOD and 
 
                     see what they think you should be doing. The company I know 
 
                     about is IPSYS; there are a number of others. From my reading 
 
                     on HOOD, the method seems to be highly Ada dependent. Although 
 
                     the HOOD manual asserts that the notation is not just another 
 
                     Ada design notation, there seems to be no guidance on how 
 
                     one might hope to map HOOD concepts onto (for example) C++. 
 
                     Perhaps things have improved since I looked. It certainly 
 
                     isn't clear to me how people manage to use HOOD in practice. 
 
                     I'd be very interested to hear from you if you find out more. 
 
                   </p>
 
                   <p align="justify">Thanks,<br>
 
                     Andrew Ormsby, <br>
 
                     aro@aber.ac.uk University of Wales, Aberystwyth. </p>
 
                   <p align="justify">From: aguilla1%agt.uucp@cs.ualberta.ca <br>
 
                     Subject: HOOD Hi!</p>
 
                   <p align="justify"> Have you looked at Shlear/Mellor's latest 
 
                     book (1991) 'Modeling the World in States'? This may give 
 
                     you some good ideas. + August Guillaume Internet: aguilla1%agt.uucp@cs.ualberta.ca 
 
                     + Senior Researcher + AGT Research &amp; Development + 500 
 
                     Capitol Square + 10065 
 
                   <p align="justify">Jasper Ave Voice: (403) 493?3677 + Edmonton, 
 
                     Alberta CAN Fax: (403) 493?4277 + T5J?3B1 
 
                   <p align="justify"> PERSONAL FIGHT From mangane@SOLEIL.matra-espace.fr 
 
                     <br>
 
                     Mon Oct 19 01:34:20 1992 <br>
 
                     Return-Path: &lt;mangane@SOLEIL.matra-espace.fr&gt; <br>
 
                     Received: from alcbel.be ([138.203.64.80]) by space.alcb </p>
 
                   <p align="justify">restrict access by other members of the University 
 
                     community to this software. I can ask that they provide proper 
 
                     acknowledgements or collaborate with me, or I can simply not 
 
                     allow others to use it. Is this correct and/or proper? Additional 
 
                     issues involve contractual agreements with the grant source 
 
                     to provide copies of papers and abstracts published using 
 
                     this software, and the need (in my mind) to build a case for 
 
                     further support. Also, what about software modifications, 
 
                     ports, shell scripts and anything else that comes under the 
 
                     heading of intellectual property? For example, if someone 
 
                     in my research group ported MOPAC to a machine on which it 
 
                     previously did not run, then I might consider that ported 
 
                     version intellectual property (with apologies to Jimmie Stewart). 
 
                     I believe that the ported version need not be made available 
 
                     to others without my permission, although I would certainly 
 
                     not restrict them from obtaining the public domain source 
 
                     code and doing the port themselves. My chairman insists that 
 
                     he can access this software without my permission and without 
 
                     even telling me that he is doing it. He has refused to speak 
 
                     with me about this, but instead has gone over my head to our 
 
                     Dean, who has (in writing) made a unilateral policy decision 
 
                     that any resources I obtain as a University employee belong 
 
                     to the University, are controlled by the University, and are 
 
                     openly available to any University employee, faculty or student, 
 
                     without that person having to contact me, the PI. Our university 
 
                     does not have a written policy on this matter. I am also under 
 
                     the impression that if the PI moves from one academic or research 
 
                     institution to another, that the grants typically move as 
 
                     well, even though they were made to the University. I also 
 
                     believe that, if negotiated, the resources purchased on that 
 
                     grant move (I cannot believe that NIH or NSF want to pay twice 
 
                     for the same glassware, chemicals, software etc. just because 
 
                     someone moved). Again, my chairman and dean are denying that 
 
                     this is the case. All comments are welcome. I am simply trying 
 
                     to understand this situation better, to learn my rights and 
 
                     obligations, and to avoid getting screwed. Please send mail 
 
                     directly to me ? I don't think we should clutter up bandwidth 
 
                     with this as an open discussion.</p>
 
                   <p align="justify"> Doug Smith Assistant Professor of Chemistry 
 
                     The University of Toledo Toledo,<br>
 
                     OH 43606-3390 <br>
 
                     voice 419-537-2116 <br>
 
                     fax 419-537-4033<br>
 
                     email dsmith@uoft02.utoledo.edu</p>
 
                   <p align="justify">-Article 12007 (158 more) in comp.software-eng: 
 
                     <br>
 
                     From: George C. Harrison, Norfolk State University <br>
 
                     Subject: Re: Programming language evaluation criteria In article 
 
                     &lt;1992Dec12.091818.1847@msus1.msus.edu&gt;, jhowatt@eeyore.stcloud.msus.e 
 
                     du (Jim Howatt) writes: </p>
 
                   <p align="justify"> I'm teaching a comparative programming languages 
 
                     class next quarter using Sebesta's second edition as the primary 
 
                     text. In the first chapter he lists several language selection/evaluation 
 
                     criteria; but the list &quot;feels&quot; uncomfortably incomplete 
 
                     and subjective. In view of the flame wars that we often see 
 
                     among proponents of different languages, I'd like to present 
 
                     my <br>
 
                     &gt; students with a set of reasonably objective criteria 
 
                     for selecting a language for a given task. <br>
 
                     &gt; Dr. James W. (Jim) Howatt <br>
 
                     &gt; Department of Computer Science <br>
 
                     &gt; 139 Engineering and Computing Center <br>
 
                     &gt; St. Cloud State University Objective criteria often have 
 
                     little to do with an implementation choice; often the reasons 
 
                     for selecting the language are subjective. Anyway, here's 
 
                     my 2 cents: 1. Is the language appropriate to the application? 
 
                     2. Availability of compilers/support tools...? 3. Cost of 
 
                     #2...? 4. Ease of learning...? 5. Current experience of programmers...? 
 
                     6. Does the language support your disign style: Object Oriented, 
 
                     Top?Down, Abstract Data Types, etc. (and mixes thereof)? 7. 
 
                     Does the customer DEMAND that a certain language be used? 
 
                     8. Maintainability support of the code...? 9. Speed and Size 
 
                     of final executable (very compiler?dependent)...? 10. Do the 
 
                     language's constructs fit the design? There are many others, 
 
                     but the bottom line is that the &quot;quality&quot; of a language 
 
                     is often application?experience dependent. Perhaps some criteria 
 
                     build around the &quot;style&quot; of the COnstructive COst 
 
                     MOdel (COCOMO) in software engineering might be an interesting 
 
                     way of evaluating a language. </p>
 
                   <p align="justify">+ | George C. Harrison <br>
 
                     | PHONE : (804) 683-8654 <br>
 
                     | &quot;Ada Spoken Here&quot;| <br>
 
                     | Professor of Computer Science <br>
 
                     | FAX : (804) 683-9229 <br>
 
                     | Norfolk State University <br>
 
                     | g_harrison@vger.nsu.edu | <br>
 
                     | 2401 Corprew Avenue <br>
 
                     | Norfolk VA 23504 <br>
 
                     | loop exit when RE_TIRED; end loop; |</p>
 
                   <p align="justify"></p>
 
                   <p align="justify"> Article 12011 (154 more) in comp.software?eng: 
 
                     <br>
 
                     From: &quot;Nigel G. Backhurst&quot; <br>
 
                     Subject: O-O and Swift Distribution: world Organization: IE 
 
                     Technical Services Holland Lines: 13 <br>
 
                     Date: Tue, 15 Dec 1992 01:49:24 +0000</p>
 
                   <p align="justify"> I have heard on the that Swift in Brussels 
 
                     have successfully used OOA and OOD on a major software project 
 
                     coded in C++. Apparently this was produced on time and underbudget. 
 
                     Anybody have any information on this, especially on what systems 
 
                     they used for development?<br>
 
                     Nigel Backhurst ( nigel@ietech.demon.co.uk )<br>
 
                     Koggestraat 10D, <br>
 
                     3028 VX Rotterdam, <br>
 
                     Netherlands IE Technical Services Holland,<br>
 
                     Deventerstr 150,<br>
 
                     7321 CE Apeldoorn, NL Netcom - Online Communication Services 
 
                     (408 241-9760 guest) </p>
 
                   <p align="justify">Date: Fri, 18 Dec 1992 08:31:34 GMT In article 
 
                     &lt;david.724561188@hawk<br>
 
                     &gt; david@hawk.adied.oz.au (David Hatley) writes:<br>
 
                     &gt;While reading the discussion on the SEI model I have noticed 
 
                     several references to SWIFT and FURPS. As I am currently looking 
 
                     at having an SEI assessment done on our company I would like 
 
                     some information on these and how they relate to the SEI model. 
 
                     FURPS modelling, to the best of my knowledge evolved at Hewlett-Packard 
 
                     Co. though I can't find anywhere in my record who the principal 
 
                     developer of this model was. The earliest usage that I can 
 
                     find comes from groups headed by Bob Grady (still at HP) and 
 
                     Chuck House (now at Informix). They might be able to provide 
 
                     more complete history. FURPS stands for Functionality, Usability, 
 
                     Reliability, Performance, and Supportability. The first principle 
 
                     of the FURPS model is that the requirements specs should describe 
 
                     the minimal acceptance criteria on ALL of these dimensions 
 
                     (later other dimensions were added and the model got different 
 
                     names: FLURPS, FLURPSL, FURPS+... but I won't go into that 
 
                     here). The point is that you don't just want to specify the 
 
                     functionality and meet that requirement but the product fails 
 
                     because the functionality is unusable, or unreliable or too 
 
                     slow, etc. So you need to be specific about what is required 
 
                     in those dimensions as well. The second principle of the FURPS 
 
                     model (as it was practiced when I was at HP which was up to 
 
                     1990) is that you should take those requirements and turn 
 
                     them from a binary characteristic to a continuum, with various 
 
                     intermediate points. This continuum is then mapped to some 
 
                     sort of ad hoc metric so that you can assign a number, say 
 
                     from 1-5 to performance vs. the specification. Then you set 
 
                     target numbers for each dimension and manage the project by 
 
                     comparing the actual metric evaluations on each dimension 
 
                     with the goal. This is often done with the use of &quot;Radar&quot; 
 
                     charts, multi?dimensional planar polar graphs with the 5 (or 
 
                     more) dimensions of FURPS measures radiating out from a central 
 
                     origin. FURPS is therefore a technique for improving requirements 
 
                     definitions, and for measuring them. Its relation to the SEI 
 
                     CMM is that you need to have a standard means to requirements 
 
                     definitions to be a defined process. The first principle addresses 
 
                     this issue, though it is not the only way , and the SEI CMM 
 
                     doesn't specify a particular method. Also, you need to be 
 
                     able to measure performance against targets to have a managed 
 
                     process, and the second principle addresses this issue. The 
 
                     origin of SWIFT, I can talk with a bit more certainty, as 
 
                     I personally developed it. This was also developed originally 
 
                     at HP, though I have done substantial refinements to it over 
 
                     the last three years since I left HP. SWIFT is a method for</p>
 
                   <p align="justify"> a) developing requirements specifications, 
 
                     designs, implementations, and tests to ensure product desirability, 
 
                     usability and profitability. And,</p>
 
                   <p align="justify"> b) for managing development from requirements 
 
                     capture through product ship and ongoing support and maintenance, 
 
                     taking into consideration not only technical/engineering success 
 
                     criteria, but also business success factors across functional 
 
                     areas, such as impact of product design on sales cycle, project 
 
                     cost, sales channel requirements, etc. I must apologize that 
 
                     remarkably little is written about it. There have been some 
 
                     comments about it's use in particular projects in some HP 
 
                     internal magazines (e.g. the now defunct COMMENT) at various 
 
                     workshops (such as the Groupware '88 Workshop associated wiht 
 
                     the World Computer Congress) and most recently some an overview 
 
                     in Marc Rettig's Practical Programmer column in the May 1992 
 
                     Communications of the ACM. This is because I have been primarily 
 
                     using this method for many years to produce products rather 
 
                     than expend effort teaching it to others. In the past three 
 
                     years, due to an increase interest by others, and some opportunities 
 
                     to share it with others, I have begun to work on getting more 
 
                     information out to the public on this method. The most notable 
 
                     aspect of SWIFT is its focus on getting concrete product specifications 
 
                     in terms of actual PROBLEM ORIENTED TASK SCENARIOS. Typically 
 
                     we use &quot;screenplays&quot; as part of the requirements 
 
                     specification and &quot;storyboards&quot; as part of the design 
 
                     specifications. These scenarios also become the basis for 
 
                     both acceptance and usability testing. (Given the sample problem 
 
                     can a novice users correctly proceed through the screenplay 
 
                     even though they have never read it?) The most notable product 
 
                     to have been developed using SWIFT in the recent past is Merge 
 
                     Ahead, which received a cover notice in the May 1992 Sun World. 
 
                     The primary method spreading the SWIFT method at this time 
 
                     is via consulting and contract training or seminars I offer. 
 
                     I also expect to offer some courses through University of 
 
                     California at Berkeley latert his year to introduce people 
 
                     to SWIFT as part of an extension certificate in software engineering 
 
                     program. I'm working on the class design right now; comments 
 
                     are welcome. I am also working on a book on this topic for 
 
                     O'Reilley &amp; Associates. We are working on the contents 
 
                     of this book right now, and welcome suggestions (send comments 
 
                     to: mcgregor @netcom.com, timo@ora.com, andyo@ora.com). The 
 
                     relationship between SWIFT and SEI CMM is complementary. As 
 
                     I have tried to explain elsewhere in this news group, SEI 
 
                     CMM is primarily focussed on ensuring that &quot;given a good 
 
                     requirements specification, produce that as predictably and 
 
                     reliably as possible). In short hand, SEI CMM is a focus on 
 
                     DOING THINGS RIGHT. SWIFT focusses on ensuring the antecedent, 
 
                     namely that what you build will be desirable to the marketplace. 
 
                     In other words, SWIFT focusses on ensuring that you are DOING 
 
                     THE RIGHT THINGS. </p>
 
                   <p align="justify">Companies benefit from doing both, though 
 
                     the former (addressed by SEI CMM) is often more crucial in 
 
                     contract software firms, while the latter is often the critical 
 
                     success factor for &quot;shrink?wrap&quot; or &quot;product&quot; 
 
                     software firms. Contract firms were much more prevalent in 
 
                     the 50s?70s (and still are in Government and Military markets 
 
                     as well as in Japan). But since the mid 80s, due largely to 
 
                     the PC, Unix and open systems the product oriented companies 
 
                     have become a greater and greater proportion of the U.S. software 
 
                     market. Internal software projects are also moving from more 
 
                     of a contract model to more of a product model. This is part 
 
                     of what I think is leading to the growth of a greater interest 
 
                     in methods like FURPS, SWIFT, and the increased interest in 
 
                     design for usability noted by Rob Kling and others.</p>
 
                   <p align="justify"> From: mat@mole-end.matawan.nj.us <br>
 
                     Subject: Re: Software Inspections. How many does it take? 
 
                     <br>
 
                     Summary: One way to do reviews Organization: : <br>
 
                     Date: Wed, 16 Dec 1992 15:31:25 GMT Lines: 52 In article &lt;1992Dec14.192008.15480@gallant.apple.com<br>
 
                     &gt;, neumann.m@applelink.apple .com (mark neumann) writes: 
 
                     <br>
 
                     &gt; Recently I have been reading Capers Jones new book &quot;Applied 
 
                     Software <br>
 
                     &gt; Measurement&quot;, McGraw Hill. ... <br>
 
                     &gt; ... However, the inspection technique he describes requires 
 
                     a <br>
 
                     &gt; bunch of people! ... <br>
 
                     &gt; All five (or more) may be present for large projects. 
 
                     For small projects dual roles can be assigned, so that the 
 
                     minimum number for a true inspection is three: moderator, 
 
                     author, and one other person. &quot; ... &<br>
 
                     gt; In my experience, when the schedule pressure is on, most 
 
                     of the attendees at large formal code walkthroughs are too 
 
                     busy with their own work to carefully go over the material 
 
                     being reviewed. Scott L. McGregor mcgregor@netcom.com President 
 
                     tel: 408?985?1824 Prescient Software, Inc. fax: 408?985?1936 
 
                     3494 Yuba Avenue San Jose, CA 95117-2967 Prescient Software 
 
                     sells Merge Ahead, the tool for Merging Text or Code and offers 
 
                     consulting &amp; training in project management and design 
 
                     for usability. </p>
 
                   <p align="justify">more inspections so on). Rather than collecting 
 
                     all of these people for a meeting, instead they're given the 
 
                     design and a list of questions to answer. They answer these 
 
                     alone in their office. People are convened only to discuss 
 
                     problems. When possible, the &quot;questions&quot; are in 
 
                     the form of tasks, such as &quot;Show how you'd use this design 
 
                     to cause the module to do task FOO with your module BAR?&quot;, 
 
                     rather than just &quot;Does the module's interface to your 
 
                     BAR module look OK?&quot; (Some of this may be my later distortions 
 
                     of their original idea; read the paper.) I try to use this 
 
                     approach in my inspections, and I use much the same principle 
 
                     in my &quot;question catalog for code inspections&quot;, available 
 
                     via anonymous FTP from cs.uiuc.edu:/pub/testing/question.ps. 
 
                     It seems to be a useful adjunct to other tricks of the trade. 
 
                   </p>
 
                   <p align="justify">Brian Marick, marick@cs.uiuc.edu, testing!marick@uunet.uu.net 
 
                     <br>
 
                     Testing Foundations: Consulting, Training, Tools. Freeware 
 
                     test coverage tool: see cs.uiuc.edu:pub/testing/GCT.README 
 
                     Article 12075 (94 more) in comp.software-eng: <br>
 
                     Newsgroups: comp.software-eng,comp.specification</p>
 
                   <p align="justify"> From: David Notkin Subject: ACM SIGSOFT 
 
                     '93: Foundations of Software Engineering (CFP) Organization: 
 
                     Computer Science &amp; Engineering, U. of Washington, Seattle 
 
                     <br>
 
                     Date: Sat, 19 Dec 92 16:41:37 GMT Lines: 93 CALL FOR PAPERS 
 
                     ACM SIGSOFT '93: </p>
 
                   <p align="justify">Symposium on the Foundations of Software 
 
                     Engineering Sponsored by ACM SIGSOFT Los Angeles, California 
 
                     USA 7-10 December 1993 The ACM SIGSOFT '93 Symposium on the 
 
                     Foundations of Software Engineering will focus on innovative 
 
                     research results that identify and contribute to the foundations 
 
                     of software engineering. The intent is to help establish software 
 
                     engineering as a viable engineering discipline. We solicit 
 
                     papers in all technical areas of software engineering. A successful 
 
                     paper is expected to report on new principles, methods, or 
 
                     results of experimentation in software engineering (which 
 
                     includes topics related to the specification, design, implementation, 
 
                     and evaluation of software systems). Papers should emphasize 
 
                     how they contribute to a foundation that allows us to effectively 
 
                     engineer classes of complex software systems in disciplined, 
 
                     reasoned ways. Unless a strong tie to software engineering 
 
                     is made, papers more central to other aspects of computer 
 
                     science should be submitted to conferences in those areas. 
 
                     A paper should clearly state the contribution and its underlying 
 
                     assumptions. It should also assess the results, making appropriate 
 
                     comparisons with and references to the literature. Papers 
 
                     will be judged on clarity, significance, relevance, correctness, 
 
                     and originality. The paper must contain ideas not previously 
 
                     presented in or currently awaiting acceptance to another formal 
 
                     forum. </p>
 
                   <p align="justify">All papers will be reviewed by program committee 
 
                     members. In some cases, additional external advice may be 
 
                     solicited by the program committee. Papers of particular merit 
 
                     may be recommended to major software engineering journals 
 
                     for expedited review. Submissions are limited to 6000 words, 
 
                     including reasonable estimates of the size of figures but 
 
                     excluding references. Overly long submissions will be returned 
 
                     without review. Fourteen copies, preferably double?sided, 
 
                     must be sent to the program chair by April 9,1993. Authors 
 
                     will be notified by July 5, 1993. Camera-ready versions of 
 
                     accepted papers are due, along with ACM copyright release 
 
                     forms, by August 27, 1993. Proceedings will be distributed 
 
                     at the symposium and as a special issue of ACM Software Engineering 
 
                     Notes. </p>
 
                   <p align="justify">Tutorials will be held on December 7, 1993. 
 
                     General Chair Barry Boehm (boehm@usc.edu) <br>
 
                     /Computer Sciences Department <br>
 
                     /University of Southern California<br>
 
                     / Los Angeles CA 90089 USA <br>
 
                     /(213) 740?8163 Program Chair David Notkin (notkin@cs.washington.edu) 
 
                     /Dept. of Computer Sci. &amp; Eng., FR?35 (Sieg 114) University 
 
                     of Washington <br>
 
                     /Seattle WA 98195 USA <br>
 
                     / (206) 685-3798 Tutorial <br>
 
                     Chair Dewayne E. Perry (dep@research.att.com) AT&amp;T Bell 
 
                     Laboratories 600 Mountain Avenue Murray Hill NJ 07974 USA 
 
                     (908) 582-2529 <br>
 
                     Program Committee Lori Clarke, University of Massachusetts 
 
                     <br>
 
                     John Gannon, University of Maryland David Garlan, Carnegie 
 
                     Mellon University Susan Gerhart, National Science Foundation 
 
                     <br>
 
                     Ross Jeffery, University of New South Wales <br>
 
                     Nancy Leveson, UC Irvine/University of Washington <br>
 
                     David Notkin, University of Washington <br>
 
                     Harold Ossher, IBM T.J. Watson Research Tom Reps, University 
 
                     of Wisconsin Murray Hill NJ 07974 USA (908) 582-2529 Program 
 
                     Committee <br>
 
                     Lori Clarke, University of Massachusetts John Gannon, University 
 
                     of Maryland David Garlan, Carnegie Mellon University <br>
 
                     Susan Gerhart, National Science Foundation<br>
 
                     Ross Jeffery, University of New South Wales Nancy Leveson, 
 
                     UC Irvine/University of Washington <br>
 
                     David Notkin, University of Washington Harold Ossher, IBM 
 
                     T.J. Watson Research <br>
 
                     Tom Reps, University of Wisconsin Bill Scherlis, DARPA SISTO 
 
                     Tetsuo Tamai,University of Tsukuba David Wile, USC/Information 
 
                     Sciences Institute Michal Young, Purdue University --<br>
 
                     David Notkin notkin@cs.washington.edu Dept. of Computer Science 
 
                     &amp; Engineering, FR-35 1-206-685-3798 University of Washington 
 
                     1-206-543-2969 (FAX) Seattle, WA 98195 </p>
 
                   <p align="justify">Subject: Re: Putting Engineering into Software 
 
                     Engineering <br>
 
                     From: Jason Baragry In article &lt;BzHKr6.DGr@fiu.edu<br>
 
                     &gt;, feathers@serss0 (Michael Feathers) writes:<br>
 
                     |&gt; In article &lt;1992Nov28.032512.26295@mole?end.matawan.nj.us<br>
 
                     &gt; mat@mole?end.mataw an.nj.us writes:<br>
 
                     |&gt; &gt;In article &lt;rzeplins.722559935@sfu.ca<br>
 
                     &gt;, rzeplins@fraser.sfu.ca (George Zygmu nt Rzeplinski) 
 
                     writes: <br>
 
                     |&gt; &gt;&gt; What is needed to call Software Engineering 
 
                     &quot;engineering&quot;<br>
 
                     |&gt; &gt;(This discussion, again?) <br>
 
                     |&gt; &gt;Models that assist understanding, communication 
 
                     and recording of analysis <br>
 
                     |&gt; &gt;and design, and that are universally applicable 
 
                     and universally indispensible. <br>
 
                     |&gt; <br>
 
                     &gt;In electrical engineering, there are circuit theory, transmission 
 
                     line<br>
 
                     |&gt; &gt;theory, and electromagnetic field theory. [...] 
 
                     <br>
 
                     |&gt; &gt; <br>
 
                     |&gt; &gt;All of these illustrate what software is missing. 
 
                     <br>
 
                     |&gt; &gt; |&gt; |&gt; Gee.. what about logic, computability 
 
                     theory, formal languages, cohesion, <br>
 
                     |&gt; coupling, and knowledge representation? <br>
 
                     |&gt; |&gt; I'd consider any of those as universally applicable 
 
                     in software engineering. <br>
 
                     |&gt; I think the difference is that in other engineering 
 
                     disciplines these modelling / analysis techniques provide 
 
                     a way to analyse the properties of the components which constitute 
 
                     the system. In these engineering fields there is a high level 
 
                     of reuse and to compare components you need some way of representing 
 
                     the properties of these components. Sure, algorithms in SE 
 
                     can be measured by speed but if I am looking at which electronic 
 
                     components I would want to reuse to meet my needs I can use 
 
                     circuit analysis, frequency &amp; phase analysis, transmission 
 
                     line theory, etc to do it. How can I analytically compare 
 
                     to high?level SE components to see which one meets my needs 
 
                     the best? (assumming people may one day actually think like 
 
                     this!) I have to rely on written documentation of what the 
 
                     thing does and how the thing does it. Perhaps there isn't 
 
                     any way of modelling high level SE components. Perhaps the 
 
                     only way to compare SE modules without simply relying on documentation 
 
                     (which is very quantifiable) is to animate those components 
 
                     and compare their operating performance. Jason. Jason Baragry. 
 
                     <br>
 
                     | Amdahl Australian Intelligent Dept Comp. Sci. &amp; Comp. 
 
                     Eng., <br>
 
                     | Tools Program La Trobe University.,<br>
 
                     | baragry@latcs1.lat.oz.au Bundoora. 3083. <br>
 
                     | Phone: +61 3 479 1477 Australia. <br>
 
                     | Fax: +61 3 470 4915 </p>
 
                   <p align="justify">From: Georg Edelmann <br>
 
                     Subject: Re: What is Software Design?</p>
 
                   <p align="justify"> Hi Michael, feathers@serss0 (Michael Feathers 
 
                     @ Florida International University, Miami) onc e wrote.... 
 
                     <br>
 
                     &gt; &gt;I've just finished reading an article in the latest 
 
                     edition of _The C++ <br>
 
                     &gt;Journal_. The article is named _What is Software Design_ 
 
                     and it was <br>
 
                     &gt;authored by Jack Reeves. <br>
 
                     &gt; &gt;The ideas that he presents confirmed my suspicions 
 
                     about some of the problems<br>
 
                     &gt;that we currently have in software engineering. I whole?heartedly 
 
                     suggest <br>
 
                     &gt;that anyone who can find the article do so and read it.<br>
 
                     &gt; If this article consists in a digital form, please post 
 
                     it. </p>
 
                   <p align="justify"> From: Paul Bandler <br>
 
                     Subject: Value of Code Coverage Analysis Metrics ? <br>
 
                     Summary Organization: ACUS Australian Centre for Unisys Software, 
 
                     Sydney <br>
 
                     Date: Mon, 21 Dec 1992 06:15:09 GMT Lines: 1115 <br>
 
                     Sender: news@lmpsbbs.comm.mot.com (Net News)<br>
 
                     Organization: Motorola Land Mobile Products Sector &lt;preamble 
 
                     deleted&gt; <br>
 
                     |&gt; I believe we have a tool to measure the %BFA 'Branch 
 
                     Flow Analysis' but <br>
 
                     |&gt; of course the engineers are responsible for producing 
 
                     the test cases to <br>
 
                     |&gt; exercise the code. <br>
 
                     |&gt; |&gt; I have 3 questions:? <br>
 
                     |&gt; |&gt; 1) Do people think that this is a valuable metric? 
 
                     <br>
 
                     |&gt; 2) Is it a cost effective excersize to get engineers 
 
                     to achieve a particular<br>
 
                     |&gt; %BFA as a completion criteria? <br>
 
                     |&gt; 3) What is a realistic %BFA to aim for? <br>
 
                     |&gt; Paul Bandler BFA is a valuable tool for testing. %BFA, 
 
                     as with all unitless numbers, is of a more dubious nature. 
 
                     %BFA does not tell the person looking at it which paths were 
 
                     not tested and why. This is important because engineers could, 
 
                     subconsciously or otherwise, use their quota of untested branches 
 
                     to avoid testing the more complex/niggly areas of code. The 
 
                     nature of the testing is also important ? only if you are 
 
                     programming in an interpreted language where syntax must be 
 
                     checked by execution, is executing every line of code useful 
 
                     by itself. (You can run through every branch of a square root 
 
                     function but it won't test for what happens with a negative 
 
                     parameter. There is always a temptation to say that a line 
 
                     i++ 'passes because it increments i' without checking when 
 
                     it shouldn't.) <br>
 
                     |&gt; same questions again Bandler BFA is a valuable tool 
 
                     for testing. %BFA, as with all unitless numbers, is of a more 
 
                     dubious nature. %BFA does not tell the person looking at it 
 
                     which paths were not tested and why. This is important because 
 
                     engineers could, subconsciously or otherwise, use their quota 
 
                     of untested branches to avoid testing the more complex/niggly 
 
                     areas of code. The nature of the testing is also important 
 
                     ? only if you are programming in an interpreted language where 
 
                     syntax must be checked by execution, is executing every line 
 
                     of code useful by itself. (You can run through every branch 
 
                     of a square root function but it won't test for what happens 
 
                     with a negative parameter. There is always a temptation to 
 
                     say that a line i++ 'passes because it increments i' without 
 
                     checking when it shouldn't.) </p>
 
                   <p align="justify">As to cost effectiveness this is so dependant 
 
                     upon the available tools, maintainance costs, whether or not 
 
                     testability was built into the code etc. that any global statement 
 
                     would be rash. A realistic %BFA target is again dependant 
 
                     upon specific circumstances. I don't know if anyone has done 
 
                     any work to find out the %age of defects found, against testing 
 
                     coverage and time taken but I would be interested to find 
 
                     out. The benefits of higher percentages are not linear and 
 
                     certainly peaks. Setting %BFA as a part of completion criteria 
 
                     is probably worthwhile but getting dogmatic about it is probably 
 
                     not. BFA is very useful for helping engineers see where more 
 
                     testing is required it is not that useful as an exam mark 
 
                     for the testing. ?? </p>
 
                   <p align="justify">David </p>
 
                   <p align="justify">All opinions are mine and not necessarily 
 
                     Motorola's ============ <br>
 
                     @mail : David Alexander, Channel Tunnel Software, Motorola, 
 
                     Lyon Way, = = Camberley (ZUK20), Surrey GU15 3QG, U.K. = = 
 
                     Email : (Internet) davidal@comm.mot.com Motorola X400?gateway 
 
                     : CDA004 = = Telephone : (office) +44 (0)276?413340 (home)+44 
 
                     (0)276-24249 </p>
 
                   <p align="justify">Subject: &gt;&gt;&gt; Value of High Code 
 
                     Coverage Metrics in Testing ? Request for Opini on Performing 
 
                     test coverage analysis on code is more of a good attitude 
 
                     than it is a silver bullet for removing bugs. There is an 
 
                     old mgmt saying, &quot;What is inspected is what gets done&quot;. 
 
                     <br>
 
                     &gt; 1) Do people think that this is a valuable metric? Again, 
 
                     it improves the code but it does not remove all bugs. Design 
 
                     flaws about cases not being handled cannot be found. Also, 
 
                     any code that uses data driven tables (e.g. finite state parsers) 
 
                     cannot be measured effectively.<br>
 
                     &gt; 2) Is it a cost effective excersize to get engineers 
 
                     to achieve a particular <br>
 
                     &gt; %BFA as a completion criteria? Sure... if you have the 
 
                     time in the schedule and effective tools to do it. Usually, 
 
                     it is best to have people do coverage analysis on their own 
 
                     code and have people who don't know the code test it for unanticipated 
 
                     conditions. <br>
 
                     &gt; 3) What is a realistic %BFA to aim for? Fairly low percentage 
 
                     of 50% is usually the maximum possible value. Much code is 
 
                     assertion testing. However, every condition should be accounted. 
 
                     Thank you. Steve Simmons From: claird@NeoSoft.com (Cameron 
 
                     Laird) In comp.software?eng you write: <br>
 
                     &gt;I have 3 questions:?<br>
 
 
                     &gt;Paul Bandler Brian Marick has written a couple of papers 
 
                     that answer your questions; they are &quot;Experience with 
 
                     the Cost of Test Suite Coverage Measures&quot; and &quot;Three 
 
                     Ways to Improve Your Testing&quot;. They discuss various types 
 
                     of code coverage, and how useful they are. Both are available 
 
                     by anonymous ftp from &lt;something<br>
 
                     &gt;.cs.uiuc.edu. Unfortunately, I don't remember what the 
 
                     &lt;something<br>
 
                     &gt; is; however, you could mail him at marick@cs.uiuc.edu, 
 
                     and I'm sure he'd be glad to tell you how to get them. ??Samuel 
 
                     Bates samuel@cs.wisc.edu Date: Mon, 14 Dec 92 09:25:53 PST 
 
                     From: Todd Huffman &lt;huffman@yoko.STAT.ORST.EDU<br>
 
                     &gt; Branch coverage metrics are quite useful, and they are 
 
                     accepted by the software engineering community at large as 
 
                     being useful. The only consideration to work out is efficiency 
 
                     of getting these numbers and cost vs. benefit for the organization. 
 
                     I heard a good comment from a seminar by Tsun Chow (he's at 
 
                     ATT Naperville, Ill.). If your line coverage is not 100% then 
 
                     you are shipping software that has never been executed. Sounds 
 
                     risky! If your branch coverage is not 100% then you are shipping 
 
                     software with branches that have never been taken. Also risky. 
 
                   </p>
 
                   <p align="justify">My experience is that this sort of metric 
 
                     collection must be automated if it is to be cost effective. 
 
                     It must be done at the UNIT test stage. Something 80 -100% 
 
                     would be useful. If programmers do not have to get 80% coverage, 
 
                     then you will have some of them release barely tested modules 
 
                     when the schedule gets tight. This sort of metric must be 
 
                     put in perspective with the whole QA program. Even with 100% 
 
                     coverage there will remain bugs. I think it is important to 
 
                     track bugs discovered by the integration/system test group 
 
                     per module. Then you will know which programmers have released 
 
                     buggy code to test. The 80% (or whatever you choose) branch 
 
                     coverage level should prevent the very bad code from being 
 
                     release and subsequent code churning. Here is a reference 
 
                     where test coverage metrics are used quite well?? &quot;Experience 
 
                     in Testing the Motif Interface&quot;, Jason Su, Paul Ritter 
 
                     (they're at Hewlett?Packard). March 1991, IEEE Software. That 
 
                     whole issue is devoted to testing??other articles are also 
 
                     good. Thats all for my 2 cents worth.<br>
 
                     Todd Huffman </p>
 
                   <p align="justify"></p>
 
                   <p align="justify"> ------------------------- From: Antonio 
 
                     Linares<br>
 
                     Subject: Integration testing versus System Testing Nntp-Posting-Host: 
 
                     sanito3 <br>
 
                     Organization: Telefonica I+D Distribution: comp<br>
 
                     Date: Tue, 22 Dec 1992 09:33:47 GMT Lines: 22 </p>
 
                   <p align="justify"><br>
 
                     I have some doubts about integration and system testing. I 
 
                     have in some book notes about integrations test and system 
 
                     test, but: ? What is de exact difference between them? ? What 
 
                     should test each of them? ? How do you separate that suite 
 
                     of tests in your organization? ? When should be done integration 
 
                     test? When system test? ? Should be integration testing a 
 
                     subset of system testing? ? How about regresion testing? ? 
 
                     Who do you think should do each kind of testing? And &quot;expert&quot; 
 
                     in the code? </p>
 
                   <p align="justify">&gt;continuously improving them.<br>
 
                     &gt;* Bruce Benson + Internet ? bwb@sei.cmu.edu + + <br>
 
                     &gt;* SSC/XPE + bbenson@xpe.ssc.af.mil <br>
 
                     &gt;| Gunter AFB, AL 36114 <br>
 
                     &gt;* (SEI Affiliate Alumni) + Voice - 205 416-4445 + US Air 
 
                     Force</p>
 
                   <p align="justify"> There is an interesting article on the management 
 
                     (or lack there of) of software projects. Redmill, F. J., &quot;Considering 
 
                     quality in the management of software?based development systems,&quot; 
 
                     Information and Software Technology, Vol 32, no 1, Jan/Feb 
 
                     1990 It basically is a management bashing article. Its quite 
 
                     amusing to read through this article and say to ones self.</p>
 
                   <p align="justify"> &quot;Yes.. My management does that...And 
 
                     that... and that...&quot; The article describes common reasons 
 
                     management gives for software projects being late and over 
 
                     budget. Management also claims that these &quot;reasons &quot; 
 
                     are technical in nature and not in the domain of management. 
 
                     The author spends several pages explaining why this is not 
 
                     true and how it is managements job </p>
 
                   <p align="justify"></p>
 
                   <p align="justify"></p>
 
                   <p align="justify">Date: 24 Apr 1991 <br>
 
                     CASE TOOLS Originally collected by: calvo@nssdca.gsfc.nasa.gov 
 
                     (Sherri Calvo) Cadre Teamwork 401-351-5950 associated with 
 
                     Project Technology Meller/Schlaer OOA capability including 
 
                     ERDs in upcoming V.4.0. Ada structure graphs (Booch/Buhr) 
 
                     CASET 714-496-8670 IPSYS Tool Building Kit Coad/Yourdon toolkit 
 
                     (no contact info) supports methodology in Yourdon's book &quot;Object?Oriented 
 
                     Analysis&quot; HOOD (Hierarchical Object Oriented Design)</p>
 
                   <p align="justify"> HOOD User's Group: HUG Administration CRI 
 
                     A/S Bregneroedvej 144 DK-3460 Birkeroed Attn: Finn Hass DENMARK 
 
                     Now mandatory for several European Space Agency projects. 
 
                     Interactive Development Environments (IDE) Vienna, VA ofc. 
 
                     703-848-8808 San Francisco 415-543-0900 sales@ide.com Extension 
 
                     of Ada design tools to handle OOPLs, primarily C++ ObjectMaker 
 
                     (a/k/a Adagen) Mark V Systems, Ltd.; 16400 Ventura Blvd., 
 
                     #319; Encino, CA 91436 818-995-7671 (voice) 818-995-4267 (fax) 
 
                     Runs under Windows, X11, Mac Tools for Yourdon, Booch, Buhr 
 
                     methodologies Code generation and reverse engineering for 
 
                     Ada, C/C++ (may be under development.) Robochart Digital Insight, 
 
                     PO Box 2095, Evergreen CO 80439-2095 303-674-5232 Interactive 
 
                     diagram editor for PC's ($96), SunView ($345); -windows version 
 
                     under development. Does hierarchical ERDs, dataflows, etc. 
 
                     summary: refereed; intended for both researchers and practitioners; 
 
                     joint US/UK editorial board </p>
 
                   <p align="justify">Software Engineering books Software Engineering 
 
                     Journal (SEJ) summary: full spectrum of articles from practical 
 
                     experience to long?term research publisher: IEE (Institution 
 
                     of Electrical Engineers) and BCS (British Computer Society); 
 
                     write to IEE Publication Sales, PO Box 96, Stevenage, Herts, 
 
                     SG1 2SD, United Kingdom. Software: Practice and Experience 
 
                     summary: not always software engineering; good rept for practice 
 
                     publisher: Wiley (see above) The Software Quality Journal 
 
                     summary: academic research and industrial case studies and 
 
                     experience publisher: Chapman &amp; Hall, Journals Promotion 
 
                     Department North America:29 West 35th Street, New York, NY 
 
                     10001-2291, USA Europe: 2-6 Boundary Row, London SE1 8HN, 
 
                     UK Research Journals Meant for presenting recent research 
 
                     results. Information and Software Technology (IST) summary: 
 
                     broad spectrum, much software engineering, software process, 
 
                     but also computer science topics. </p>
 
                   <p align="justify">Subject: General reading for software engineers 
 
                     <br>
 
                     Originally collected by: cml@cs.UMD.EDU (Christopher Lott) 
 
                     <br>
 
                     Summary: responses to &quot;what should every software engineering 
 
                     have read?&quot;</p>
 
                   <p align="justify"> 1. General a. Read about 100 pages of comp.risks 
 
                     b. Frederick P. Brooks, Jr., The Mythical Man-Month, Addison 
 
                     Wesley, 1978. ISBN 0-201-00650-2 c. The anecdotal books of 
 
                     Robert College, PA 16804, including: &quot;Tales of Computing 
 
                     Folk: Hot Dogs and Mixed Nuts&quot;, &quot;The Universal Elixir 
 
                     and other Computing Projects Failed&quot;, &quot;The Second 
 
                     Coming: More Computing Projects Which Failed&quot;, &quot;The 
 
                     Power of Peonage&quot;, &quot;Computing Catastrophes&quot;, 
 
                     &quot;Computing Shakeout&quot;, &quot;Software Folklore&quot; 
 
                     d. Paul W. Oman &amp; Ted G. Lewis, Milestones in Software 
 
                     Evolution, IEEE Computing Society, ISBN 0?8186?9033?X. e. 
 
                     J.A. McDermid (editor), Software Engineer's Reference Book, 
 
                     Butterworth-Heinemann Ltd., 1991. ISBN No: 0 750 61040 9. 
 
                     Focuses on the foundations, and subject matter that is not 
 
                     volatile. The book is divided into three major parts: Theory 
 
                     and Mathematics; Methods, Techniques, and Technology; Principles 
 
                     of Applications. For a beginner, the first two parts are indispensible. 
 
                     It does not provide details of current research, but points 
 
                     an interested reader to the right sources.</p>
 
                   <p align="justify"> 2. Programming in the large <br>
 
                     a. Grady Booch, Software Engineering with Ada, second edition, 
 
                     Benjamin/Cummings, 1987 <br>
 
                     b. Bertrand Meyer, Object-Oriented Software Construction, 
 
                     Prentice?Hall, 1988. <br>
 
                     c. David L. Parnas, On the Criteria to be Used in Decomposing 
 
                     Systems into Modules, Communications of the ACM 15,2 (December 
 
                     1972).</p>
 
                   <p align="justify"> 3. Programming in the small <br>
 
                     a. Jon Louis Bentley, Writing Efficient Programs, Prentice-Hall, 
 
                     1982. <br>
 
                     b. Jon Bentley, Programming Pearls, Addison-Wesley, 1986. 
 
                     <br>
 
 
                     c. Jon Bentley, More Programming Pearls, Addison-Wesley, 1988. 
 
                     <br>
 
                     d. O.-J. Dahl, E.W. Dijkstra, C.A.R. Hoare, Structured Programming, 
 
                     Academic Press, 1972. <br>
 
                     e. Brian W. Kernighan, and P.J. Plauger, Software Tools, Addison-Wesley, 
 
                     1976.<br>
 
                     f. Brian W. Kernighan &amp; P.J. Plauger, The Elements of 
 
                     Programming Style, Second Edition, McGraw-Hill, 1978. ISBN 
 
                     0-07-034207-5. </p>
 
                   <p align="justify">4. Mathematical Approaches<br>
 
                     a. Edsger W. Dijkstra, A Discipline of Programming, Prentice-Hall, 
 
                     1976.<br>
 
                     b. E.W.Dijkstra. Selected writings on computing: a personal 
 
                     perspective. Springer Verlag, 1982. Reliable Software. The 
 
                     Institute of Electrical and Electronics Engineers, Inc 345 
 
                     East 47th Street, New York. IEEE Standard Board, Corrected 
 
                     Edition, October 23, 1989 <br>
 
                     k. T.J. McCabe, A Complexity Measure, IEEE Transactions on 
 
                     Software Engineering, VOL. SE-2, NO. 4, Dec. 1976. <br>
 
                     l. Alan Perlis, Frederick Sayward, Mary Shaw. Software Metrics: 
 
                     An Analysis and Evaluation. The MIT Press, 1981 <br>
 
                     m. V.Y. Shen, S.D. Conte, H.E. Dunsmore, Software Science 
 
                     Revisited: A Critical Analysis of the Theory and Its Empirical 
 
                     Support, IEEE Transactions on Software Engineering, Vol. SE-9, 
 
                     No. 2, March 1983. Abstract: a critical evaluation of Halstead's 
 
                     software science metric. <br>
 
                     n. M. Shepperd, Software Engineering Metrics, McGraw-Hill, 
 
                     for publication 1991. ISBN 0?07?707410?6 (UK) McGraw-Hill 
 
                     Book Company (UK) Limited, Shoppenhangers Road, Maidenhead, 
 
                     Berkshire, SL6 2QL. Tel: +44 (0)698 23431/2 Fax: +44 (0)698 
 
                     770224 <br>
 
                     o. Horst Zuse, Software Complexity: Measures and Methods, 
 
                     de Gruyer (200 Saw Mill River Road, Hawthorne, NY 10532 - 
 
                     914/747-0110) </p>
 
                   <p align="justify">Subject: User Interface Design<br>
 
                     Date: 9 Jul 1991 See also the item on Human Factors. Software 
 
                     Technical report ES-TR-86-278 Electronic Systems Division 
 
                     The MITRE Corporation Bedford, MA 01730. </p>
 
                   <p align="justify">A tech report rather than a book, but looks 
 
                     to be a good refence for issues. Also available as a hypertext. 
 
                     <br>
 
                     c. Paul Heckel, The Elements of Friendly Software Design: 
 
                     The New Edition. Sybex Inc. 1991. Original edition: Warner 
 
                     Books, 1984.<br>
 
                     d. Walter E. Gilmore, The User-Computer Interface in Process 
 
                     Control: A Human Factors Engineering Handbook. Boston:Academic 
 
                     Press, 1989. Is said to give references to research upon which 
 
                     it is based. <br>
 
                     e. Edward A. Fox (editor), Resources in Human-Computer Interaction, 
 
                     ACM Press, 1990. ISBN 0-89791-373-6. <br>
 
                     f. Gavriel Salvendy (editor), Handbook of Human Factors, John 
 
                     Wiley and Sons, 1987. </p>
 
                   <p align="justify">Subject: Software Testing <br>
 
                     Date: 9 Jul 1991 <br>
 
                     The original request that prompted the posting of this information 
 
                     asked for recent work, not buried in a Software Engineering 
 
                     tome. <br>
 
                     a. Boris Beizer, Software Testing Techniques, Van Nostrand 
 
                     Reinhold, 1990 (2nd edition) ISBN 0-442-20672-0. 503 pages, 
 
                     $43. Has 37-page annotated bibliography of references. <br>
 
                     b. Cheatham and Mellinger, Testing Object Oriented Software 
 
                     Systems, Proceedings of the 1990 ACM SCS Conference <br>
 
                     c. William C. Hetzel, The Complete Guide to Software Testing, 
 
                     Second edition, QED Information Services INC, 1988. ISBN 0-89435-242-3 
 
                   </p>
 
                   <p align="justify">Subject: Requirements Analysis <br>
 
                     Date: 18 Sep 1991 <br>
 
                     a. Al Davis, Software Requirements: Analysis and specification. 
 
                     Prentice/Hall, 1990. Has some treatment of all of the popular 
 
                     requirements analysis and specification methods including 
 
                     OOA, Structured Analysis, SREM, FSM, but not the &quot;trendy&quot; 
 
                     stuff (Information Engineering, JAD). <br>
 
                     b. Donald C. Gause and Gerald M. Weinberg, Exploring Requirements: 
 
                     Quality before design. Dorset House Publishing, 353 West 12th 
 
                     Street, New York, NY 10014 ===================================================================================== 
 
                     Title: Software Quality and Productivity Author: Alec Sharp 
 
                     Publisher: Van Nostrand Reinhold ISBN: 0?442?01218?7 Price: 
 
                     $44.95 Synopsis: This book is targeted at software developers, 
 
                     and attempts to apply the philosophy of W. Edwards Deming 
 
                     to software development. Throughout the book the emphasis 
 
                     is on two things ? reducing rework, and continually improving 
 
                     the system. </p>
 
                   <p align="justify"></p>
 
                   <p align="justify"> Article 12168 (1 more) in comp.software?eng: 
 
                     Subject: Workshop on Studies of Software Design From: David 
 
                     Lamb Date: Thu, 31 Dec 1992 19:09:45 GMT Followup?To: poster 
 
                     Organization: Computing &amp; Information Science, Queen's 
 
                     University at Kingston Lines: 69 Second (final) Call for Participation: 
 
                     Workshop on Studies of Software Design May 17?18, 1993 Baltimore, 
 
                     Maryland (overlapping the tutorial days of the International 
 
                     Conference on Software Engineering) Aim: The workshop is intended 
 
                     to provide an opportunity for those who study software designs 
 
                     and design methods to meet informally and exchange ideas. 
 
                     The emphasis is on methods for studying, analysing, and comparing 
 
                     designs and design methods, rather than on specific design 
 
                     methods themselves. Furthermore, we focus primarily on the 
 
                     &quot;software architecture&quot; level of design, and on 
 
                     techniques suitable for dealing with large systems. Topics 
 
                     include (but are not limited to): o Methods for studying, 
 
                     analysing, and comparing software architectures. o Representations 
 
                     of software designs, especially those not tied to a particular 
 
                     design method. o Properties of software designs, especially 
 
                     those that characterize or typify the method according to 
 
                     which the software was designed. o Methods of reasoning about 
 
                     designs. Format: The workshop will consist of a mix of presentations 
 
                     &amp; discussions.Informal Proceedings will be available at 
 
                     the workshop. Itmayprove possible to publish selected papers 
 
                     in a more formal way. Participation: Space at the workshop 
 
                     is limited to permit discussion; participation is by invitation 
 
                     only. Researchers are invited to submit either o An extended 
 
                     abstract of about 2000 words, if they wish to present a paper, 
 
                     or o A resume of relevant experience, if they wish to participate 
 
                     but not present a paper. For multiple?author abstracts, please 
 
                     designate a primary author, the one who will attend if the 
 
                     abstract is accepted. If the secondary authors wish to attend, 
 
                     please also supply a resume of relevant experience, so that 
 
                     we include (but are not limited to): o Methods for studying, 
 
                     analysing, and comparing software architectures. o Representations 
 
                     of software designs, especially those not tied to a particular 
 
                     design method. o Properties of software designs, especially 
 
                     those that characterize or typify the method according to 
 
                     which the software was designed. o Methods of reasoning about 
 
                     designs. </p>
 
                   <p align="justify">Dates: Submission of papers or resumes: January 
 
                     18th 1993 Invitations issued by: February 22nd, 1993 Final 
 
                     camera?ready papers due by: March 29th, 1993. The workshop 
 
                     takes place 8:30 a.m. to 5pm on Monday May 17, and Tuesday 
 
                     May 18. Details of registration will be sent with invitations. 
 
                     Sponsored in part by the Information Technology Research Centre 
 
                     of Ontario. This workshop is independent of ICSE, but co?located 
 
                     with it. Workshop Chair: David Alex Lamb Software Technology 
 
                     Laboratory Department of Computing and Information Science 
 
                     Queen's University Kingston Ontario CANADA K7L 3N6 (Phone) 
 
                     +1 613 545 6050 (or 6067) (Fax) +1 613 545 6513 (Email) dalamb@qucis.queensu.ca 
 
                     Send electronic mail submissions and queries to: ssd?workshop@qucis.queensu.ca 
 
                     We prefer LaTeX format submissions. ?? Software Technology 
 
                     Laboratory dalamb@qucis.queensu.ca (David Alex Lamb) Computing 
 
                     and Information Science phone: (613) 545?6067 Queen's University, 
 
                     Kingston, Ontario, Canada K7L 3N6 End of article 12168 (of 
 
                     12169)??what next? [npq] </p>
 
                   <p align="justify"> </p>
 
                   <p align="justify">Subject: Re: OOA&amp;D Methodologies From: 
 
                     Date: 9 Dec 92 16:03:54 GMT Nntp?Posting?Host: dn73.dse.beckman.com 
 
                     <br>
 
                     &gt;rr@phavl.UUCP (rob) writes: <br>
 
                     &gt;an <br>
 
                     &gt;&gt;In article &lt;88289@bcsaic.boeing.com<br>
 
                     &gt; Patrick Podenski writes: <br>
 
                     &gt;&gt;&quot;... had simply created yet another object?modeling 
 
                     methodology (YAO?MM).&quot; <br>
 
                     &gt;&gt;What are the well respected OOD, OOA, OOI methodologies? 
 
                     <br>
 
                     &gt;&gt;I've found Booch's method, and OMT (Rumbaugh et al). 
 
                     <br>
 
                     &gt;&gt;What else is worth looking at? I have been monitoring 
 
                     and participating in the OO discussions on the net for quite 
 
                     a while. Based upon the mail I have received, the most popular 
 
                     methodologies are <br>
 
                     (1) Object-Oriented Modeling and Design (Rumbaugh et al) and 
 
                     <br>
 
                     (2) Object-Oriented Design with Applications (Booch). </p>
 
                   <p align="justify">It has been my recommendation that the Rumbaugh 
 
                     techniques be used as the primary methodology and that it 
 
                     be supplemented by the many pearls-of-wisdom that can be found 
 
                     throughout Grady's book. To be more specific, we do not agree 
 
                     totally with Rumbaugh on every point, but we like his notation; 
 
                     Booch helps shape our OO philosphy (sometimes to a greater 
 
                     extent than Rumbaugh); furthermore, Grady has some concepts 
 
                     (like object timing diagrams) that we find very useful (since 
 
                     we develop in a real?time, multi-tasking environment). Another 
 
                     topic I would like to bring up is CASE tools?? especially 
 
                     OO CASE tools. So far I am not very impressed but I would 
 
                     buy any CASE tool that allows me to annotate any diagram artifact 
 
                     (this is critical to capturing the HOW and WHY of your analysis 
 
                     and design so that you do not forget and so others can step 
 
                     into your mind). Thanks for listening. Jim O'Hearn, Software 
 
                     Engineer Beckman Instruments Inc., Diagnostic Systems Group 
 
                   </p>
 
                   <p align="justify"></p>
 
                   <p align="justify"></p>
 
                   <p align="justify"></p>
 
                   <p align="justify">Subject: Re: OO &amp; transaction handling 
 
                     systems <br>
 
                     Organization: Cadre Technologies Inc., Providence, RI I don't 
 
                     have ready answers for all your questions, but here are some... 
 
                     <br>
 
                     &gt;Currently we program in C &amp; Oracle on a Pyramid MIS. 
 
                     The thing that <br>
 
                     &gt;attracts me to an object way of doing things is that we 
 
                     have a large <br>
 
                     &gt;number of types of transactions. There are also many types 
 
                     of <br>
 
                     &gt;customers each of which have different functions associated 
 
                     with them. <br>
 
                     &gt;'Sounds object?like, doesn't it? Sure does. Something 
 
                     you might run into is the &quot;cross?product&quot; problem. 
 
                     In your case this is types_of_customers vs. types_of_transaction. 
 
                     This typcially results in a large number of possible combinations, 
 
                     not all of which are unique. Beware of trying to solve this 
 
                     all with inheritance!! This particular problem may be better 
 
                     solved with a third set of classes that treat the combinations 
 
                     of transactions vs. customres.</p>
 
                   <p align="justify"> Try to keep any knowledge of customer types 
 
                     out of the transactions, and vice versa. Let this third &quot;owner&quot; 
 
                     class worry about the cross-product. If you're really compelled 
 
                     to use inheritance, you could create &quot;mix-ins&quot; with 
 
                     multiple inheritance that let you combine the attributes of 
 
                     the appropriate sub?types. &gt;<br>
 
                     3) Are there any products that can help with storage / access 
 
                     <br>
 
                     &gt; considerations? There are several OO database systems 
 
                     (e.g., Object Design) available now that map the objects in 
 
                     memory directly to disk and back, so you don't have to go 
 
                     through the conversion process. <br>
 
                     &gt;4) It is said that OO systems don't necessarily have performance 
 
                     problems. <br>
 
                     &gt; Is that true for OO systems as they grow in size? The 
 
                     size and <br>
 
                     &gt; complexity were exactly why one chooses a relational 
 
                     DB. OO may help <br>
 
                     &gt; me with the complexity, but can handle the amount of 
 
                     data? Recall<br>
 
                     &gt; 5 years ago relational DB were said to have performance 
 
                     problems in <br>
 
                     &gt; this regard. I can only comment on C++ here. A well?designed 
 
                     C++ implementation has no inherent performance penalites over 
 
                     C. The problem is the &quot;well?designed&quot; qualification. 
 
                     New C++ users are prone to mis?using inheritance and virtual 
 
                     functions, and ignoring really important aspects, which are 
 
                     encapsulation, decoupling, and cohesion. This can cause the 
 
                     implementation to become overly complex or convoluted, which, 
 
                     of course, leads to inefficiency.<br>
 
                     * Joe Cascio u-wm- * Cadre Technologies Inc. /<br>
 
                     \ * 222 Richmond St. 0_<br>
 
                     / &quot;$@ * Providence, RI 02903 USA <br>
 
                     \ * phone: 401-351-5950 | . . * FAX : 401-455-6803 /<br>
 
                     | * email: jc@cadre.com / | . </p>
 
                   <p align="justify">From: Lisa Brown <br>
 
                     Subject: Summary on OO training Originator: saslbb@chestnut.unx.sas.com 
 
                     <br>
 
                     Date: Tue, 22 Dec 1992 15:53:40 GMT Nntp-Posting-Host: chestnut.unx.sas.com 
 
                     <br>
 
                     Organization: SAS Institute Inc. </p>
 
                   <p align="justify">I posted an article a few days ago requesting 
 
                     information on OO programming and design training. The following 
 
                     is a summary of the responses I have received so far. I want 
 
                     to thank everyone again that sent me information. I took a 
 
                     semaphore class once. It was a one week c++/OO design course 
 
                     and it was quite useful with the one exception I think applies 
 
                     to all &quot;corporate education&quot; classes I've been to: 
 
                     Many of the people attending had not so much as skimmed through 
 
                     A good text on the subject and much time was spent on rather 
 
                     basic questions. If you do take one of these courses, (and 
 
                     it IS worth taking some sort of formal training if it is not 
 
                     too inconvient) be cure to have read through a good book on 
 
                     the subject (preferably the one that they are using) and talk 
 
                     to some experienced co-workers if at all possible... you'll 
 
                     learn a lot more if you do..</p>
 
                   <p align="justify">I just got info from GE (1-800-GE-TRAIN). 
 
                     The course is based on their in-house developed OO method 
 
                     (the Rumbaugh, et al book). Also they sell software to develop 
 
                     software with this method. I can't recommend or not recommend 
 
                     (haven't taken the course). But call the number and you'll 
 
                     get their info packet. You need look no 
 
                     further than your own back yard for the best in OO training. 
 
                     Knowledge Systems Corp., (of Cary NC) has been training programmers 
 
                     in OO A&amp;D and Smalltalk programming for over six years. 
 
                     We have one of the biggest and most established bases of OO 
 
                     expertise in the country, and have worked with many fortune 
 
                     500 companies to help them make the transition to object technology. 
 
                     Please call one of our account executives at (919) 481?4000. 
 
                     They can let you know when our next open enrollment classes 
 
                     will begin, and what other services we can offer. </p>
 
                   <p align="justify"> OO CASE You have to ask first what language 
 
                     you what to learn then what OOM you what to follow!?? I send 
 
                     some address of company that they support or produce OO CASE 
 
                     tools usually those company can give training or at least 
 
                     advise you.I hope that will help!? Another Tool you might 
 
                     want to look into is the OMT developed by GE's Research C 
 
                     enter. You can contact the Advanced Concepts Center in Valley 
 
                     forge PA or give me a call and I can give you some names there. 
 
                     <br>Phil Magrogan 315.456.3096 Andersen Consulting Chicago, Il. 
 
                 <br>    Foundation MVS, PC-DOS, OS/2, VAX/VMS, GCOS <br>Object-oriented 
 
                     full life-cycle tools Bachman Information Systems<br> Burlington, 
 
                     Ma. 800-222-4626 Bachman Data Analyst PC-DOS, OS/2 Data Modeling 
 
                     and analysis with OO support Cadre Technologies Providence, 
 
                     R.I. Macintosh Multiuser, OO development toolset Interactive 
 
                     Development Environments San Francisco, Ca. Software Through 
 
                     Pictures VAX/VMS, <br>Unix Object-oriented structured design with 
 
                     multi?user OO data dictionary Wasserman's OOSD Knowledge Garden, 
 
                     Inc. Nassau, N.Y. KnowledgePro / Windows Windows OO Development 
 
                     environment with C++ code generation </p>
 
                   <p align="justify">Mark V Software Encino, Ca. 818?995?7671 
 
                     ObjectMaker Windows, Unix, Macinstosh Object?oriented analysis 
 
                     and design Berard, Booch, Coad/Yourdon, Colbert, Rumbaugh, 
 
                     and others Windows, OS/2 Object?oriented design </p>
 
                   <p align="justify"> Protosoft Houston, Tx. 713?480?3233 Paradigm 
 
                     Plus Windows, Unix, OS/2 CASE toolset supporting Berard (EVB), 
 
                     Booch, Coad/Yourdon, and others Rational Santa Clara, Ca. 
 
                     408?496?3700 Rose Unix, AIX Object?oriented analysis and design 
 
                     Booch Semaphore North Andover, Ma. 508?794?3366 or 800?937?8080 
 
                     ATRIOM No! You are not breaking new ground but I guess the 
 
                     ground is still not that much cultivated. </p>
 
                   <p align="justify"> There is an interesting article on OO and 
 
                     Transaction Processing by John Tibbetts of Kinexis in OOPSLA 
 
                     91, Phoenix, Arizona, 6?11 October, which deals with precisely 
 
                     the kind of issues you are raising. There is quite a bit of 
 
                     work going on in this area. If you want a good book on OO 
 
                     databases, a good start is ``OO databases'' by John Hughes, 
 
                     published by Prentice?Hall.
 
                    <br> ! Jeremy Wilson <br>! email: jcrw@fmg.bt.co.uk ! <br>! Room 3?07 ! 
 
                     Telephone: 0473?227822 <br>! ! BT Development and Procurement 
 
                    <br> ! International: +44 473-227822 ! <br>! Bibb Way <br>! Facsimile: 
 
                     0473?210182 !<br> ! IPSWICH ! International: +44 473?210182 ! 
 
                     <br>! Suffolk IP1 2EQ ! Telex: 987705 ! ! United Kingdom ! International: 
 
                     +51 987705 
 
                   </p>
 
                   <p align="justify"> From: Bernhard Rumpe<br>
 
                     Subject: A little glossary for objects <br>
 
                     Originator: rumpe@sunbroy25.informatik.tu-muenchen.de <br>
 
                     Organization: Technische Universitaet Muenchen, Germany <br>
 
                     Date: Wed, 23 Dec 1992 15:12:38 GMT Little glossary of object 
 
                     oriented software developement </p>
 
                   <p align="justify">This paper is one result of a workshop over 
 
                     software development of three partners from software industry 
 
                     and universities. The glossary is a mixture of different views: 
 
                     a practical and a formal one, according to the backgrounds 
 
                     of the partners. This glossary aims at giving small, rather 
 
                     formal definitions of object oriented notions. The definitions 
 
                     are neither exact mathematic definitions nor do they correspond 
 
                     exactly to the definitions used in the area of algebraic specifications. 
 
                     We do not claim to cover the whole area of object orientation 
 
                     with our definitions (but we tried to cover a large part). 
 
                     The state of an object is represented by values and references 
 
                     to objects. The state is constituted by the values and the 
 
                     states of all referenced objects. MESSAGE Objects communicate 
 
                     with each other by sending messages. </p>
 
                   <p align="justify">A message denotes a receiver, an operation 
 
                     and carries arguments.<br> OPERATION An operation describes an 
 
                     algorithm that is executed whenever an object receives an 
 
                     appropriate message. The operation may inspect and change 
 
                     the state of the object and may send other messages. Comment: 
 
                     The operation processes the arguments carried by the message. 
 
                    <br> OBJECT SIGNATURE An object signature is a description of the 
 
                     messages understood by the object. <br>CLASS A class is a description 
 
                     of the object signature, behaviour and structure of objects. 
 
                     An object belongs to exactly one class. Comments: - The structure 
 
                     determines the set of possible states of the objects. <br>- The 
 
                     behaviour is determined by the operations of the objects. 
 
                     <br>- A class corresponds to an abstract data type. <br>- In some 
 
                     languages classes are also objects.<br>- In some languages &quot;prototype 
 
                     objects&quot; take the role of classes. <br>CLASS SPECIFICATION 
 
                     A class specification consists of a signature and a description 
 
                     of the semantics of all objects of a class. <br>INHERITANCE Inheritance 
 
                     is a binary, transitive, acyclic relation on classes. A subclass 
 
                     inherits the class specification (signature and behaviour) 
 
                     of a superclass and may extend it. <br>Comments: - A class may 
 
                     have one or several direct superclasses. This is called single 
 
                     or multiple inheritance respectively. <br>- In many languages 
 
                     a subclass inherits also the structure of a superclass and 
 
                     may extend it. <br>- The term &quot;inheritance&quot; is sometimes 
 
                     (mis?)used for code reuse violating the subfamily relation. 
 
                     <br>FAMILY A family is the set of all objects that belong to the 
 
                     associated class or one of its subclasses. <br>Comments: <br>- A family 
 
                     is a set of objects which satisfy at least the class specification 
 
                     of its associated class. <br>- A family associated to a subclass 
 
                     is called a subfamily. <br>- The inheritance relation among classes 
 
                     corresponds to the subfamily relation of the associated familys. 
 
                     <br>- The term &quot;inheritance&quot; is sometimes (mis-)used 
 
                     for code reuse violating the subfamily relation. POLYMORPHISM 
 
                     Polymorphism allows the binding of different meanings to the 
 
                     same name. <br>Comments: - In object?oriented languages at least 
 
                     two kinds of polymorphism are possible: overloading and inheritance 
 
                     polymorphism.<br> OVERLOADING (ad hoc polymorphism) Overloading 
 
                     denotes the use of the same name for different operations 
 
                     distinguished by number and kind of arguments (operation signat 
 
                     OVERLOADING (ad hoc polymorphism) Overloading denotes the 
 
                     use of the same name for different operations distinguished 
 
                     by number and kind of arguments (operation signature). INHERITANCE 
 
                     POLYMORPHISM An object of a subclass may be used whenever 
 
                     objects of any of its superclasses can be used. <br>Comments: 
 
                     <br>- This fact implies the use of the same message for different 
 
                     operations. <br>-The selection of the operation is based on the 
 
                     actual class of the receiving object.  
 
                     Bernhard Rumpe Inst. f. Informatik (SB3), Technische Univ. 
 
                     Muenchen Postfach 20 24 20, 8000 M&quot;unchen 2, Germany 
 
                     rumpe@informatik.tu-muenchen.de phone: ++49-89-2105-8129 fax 
 
                     -8183 End of article 8966 (of 9004)??what next? [npq] </p>
       <!-- InstanceEndEditable --> 
      <div class="returntotop"><a href="#home">return to top</a></div>
			
	</div>
   
</div>
</div>

<div id="footer">
<p>&#169; 2012 Center for the Study of Ethics in the Professions at IIT Hermann Hall, Rm. 205 3241 S Federal Street Chicago, IL 60616 
<br /> Phone: 312.567.3017 Fax: 312.567.3016 Email: csep@iit.edu </p>
</div>
</div>
</body>
<!-- InstanceEnd --></html>